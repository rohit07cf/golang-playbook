package main

// gRPC Echo Server
//
// This server implements the EchoService defined in echo.proto.
// It listens on :50051 and echoes messages back with server_time.
//
// IMPORTANT: This file requires generated protobuf code to compile.
// See ../generated/README.md for protoc setup instructions.
//
// Once generated code exists, run:
//   go run ./12_capstone_projects/01_grpc_echo_service/go/server

import (
	"context"
	"fmt"
	"log"
	"net"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	// Import path matches go_package in echo.proto
	// After running protoc, the generated package will be here:
	pb "go-backend-interview-prep/12_capstone_projects/01_grpc_echo_service/go/generated/echopb"
)

// --- Server Implementation ---

// echoServer implements the EchoServiceServer interface (generated by protoc).
type echoServer struct {
	pb.UnimplementedEchoServiceServer
}

// Echo handles an incoming EchoRequest and returns an EchoResponse.
func (s *echoServer) Echo(ctx context.Context, req *pb.EchoRequest) (*pb.EchoResponse, error) {
	// Check if context is already cancelled (deadline exceeded)
	if ctx.Err() != nil {
		return nil, status.Error(codes.DeadlineExceeded, "deadline exceeded before processing")
	}

	log.Printf("[server] received: message=%q request_id=%q", req.Message, req.RequestId)

	// Simulate some processing time
	time.Sleep(50 * time.Millisecond)

	return &pb.EchoResponse{
		Message:    fmt.Sprintf("echo: %s", req.Message),
		RequestId:  req.RequestId,
		ServerTime: time.Now().UTC().Format(time.RFC3339),
	}, nil
}

// --- Main ---

func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	srv := grpc.NewServer()
	pb.RegisterEchoServiceServer(srv, &echoServer{})

	log.Println("gRPC echo server listening on :50051")
	if err := srv.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}
